===== .github/workflows/build.sh =====
bash .github/workflows/setup.sh
cd lib
wasm-pack build --target web
cd ..
rm -r dist
mkdir dist
cp src/* dist/
cp -r lib/pkg/* dist/
===== .github/workflows/deploy.yml =====
name: Deploy static site

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Check out the repository
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Delete existing GitHub Pages deployment
        run: |
          curl -X DELETE \
          -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          https://api.github.com/repos/${{ github.repository }}/pages

      - name: Install dependencies
        run: npm install

      - name: Build the project
        run: npm run build

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./dist
          publish_branch: gh-pages
===== .github/workflows/git-log-files.sh =====
git ls-tree -r --name-only HEAD | while read file; do
  echo "===== $file ====="
  git show HEAD:"$file"
  echo
done > full_repo_last_commit.txt
===== .github/workflows/log.sh =====
git log --reflog --pretty=format:'%h% - %d%Creset %s %Cgreen(%cr) %C(bold blue)<%ad>%Creset %an' --date=short > log.txt

===== .github/workflows/quick-build.sh =====
rm -r dist
mkdir dist
cp src/* dist/
cp -r lib/pkg/* dist/
===== .github/workflows/run.sh =====
bash .github/workflows/build.sh
node index.js
===== .github/workflows/setup.sh =====
if ! command -v rustup &> /dev/null
then
    echo "rustup not found, installing..."
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    source $HOME/.cargo/env
else
    echo "rustup is already installed"
fi

rustup update
rustup default stable
rustup target add wasm32-unknown-unknown
cargo install wasm-pack
===== .gitignore =====
#OPTIMAL GIT LOG COMMAND: git log --reflog --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%ad>%Creset %an' --date=short > log.log

misc/target
misc/Cargo.lock
rustplayground/
notes.txt
marching-cubes-main/

# Generated by Cargo
# will have compiled files and executables
lib/debug/
lib/target/
lib/pkg/

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
lib/Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb

# RustRover
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

dist/
node_modules
.idea
lib/src/command_macro/target


# Generated by Cargo
# will have compiled files and executables
lib/debug/
lib/target/
lib/pkg/

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
lib/Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb

# RustRover
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

dist/
node_modules
.idea
lib/src/command_macro/target
node_modules
===== LICENSE =====
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <https://unlicense.org>

===== README.md =====
# Atomica
A web based molecular dynamics simulator implemented in rust

[Click here to access Atomica in your browser](https://bobdagithubaccount.github.io/Atomica/)

Do 'help' for a list of commands and [click here](https://github.com/BobDaGithubAccount/Atomica/wiki) to view the wiki for the project.
===== index.js =====
const express = require('express');
const path = require('path');
const app = express();
const port = 3000;

app.use(express.static(path.join(__dirname, 'dist')));

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
===== lib/Cargo.toml =====
[package]
name = "atomica_lib"
version = "0.1.0"
edition = "2021"
repository="https://github.com/BobDaGithubAccount/Atomica"
license-file = "UNLICENSE"
description = "Atomica rust internals"

[dependencies]
wasm-bindgen = "0.2"
wasm-bindgen-futures = "0.4"
web-sys = { version = "0.3", features = ["Window", "HtmlElement", "Document"] }
three-d = "0.17.0"
log = "0.4"
winit = "0.28"
lazy_static = "1.4.0"
console_error_panic_hook = "0.1"
console_log = "1"
js-sys = "0.3"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
ndarray = "0.15"
nalgebra = "0.31"
statrs = "0.16" # std erf unstable and needs rust nightly

### Earmarked for removal
# Remove: ndarray-linalg = "0.14" NOTE: IT DOESN'T WORK! (for wasm)
itertools = "0.10"
getrandom = { version = "0.2", features = ["js"] }
rustfft = "6.3.0"

[lib]
crate-type = ["cdylib", "rlib"]

===== lib/src/commands.rs =====
use std::collections::HashMap;
use std::sync::Mutex;
use lazy_static::lazy_static;
use crate::log;

#[derive(Clone)]
pub struct Command {
    pub name: &'static str,
    pub func: fn(Vec<String>),
    pub help: &'static str,
    pub usage: &'static str,
}

lazy_static! {
    pub static ref COMMAND_REGISTRY: Mutex<HashMap<&'static str, Command>> = Mutex::new(HashMap::new());
}

pub fn register_command(command: Command) {
    COMMAND_REGISTRY.lock().unwrap().insert(command.name, command);
}

#[macro_export]
macro_rules! register_command {
    ($name:expr, $func:expr, $help:expr, $usage:expr) => {
        $crate::commands::register_command($crate::commands::Command {
            name: $name,
            func: $func,
            help: $help,
            usage: $usage,
        });
    };
}

pub fn init() {
    register_command!("help", help_command, "Prints help information", "help [command]");
}

fn help_command(args: Vec<String>) {
    let registry = COMMAND_REGISTRY.lock().unwrap();
    let mut log_messages = Vec::new();
    log(format!("Help:"));
    if args.is_empty() {
        for command in registry.values() {
            log_messages.push(format!("{}: {} | {}", command.name, command.help, command.usage));
        }
    } else {
        for arg in args {
            if let Some(command) = registry.get(&arg[..]) {
                log_messages.push(format!("{}: {} | {}", command.name, command.help, command.usage));
            } else {
                log_messages.push(format!("Command not found: {}", arg));
            }
        }
    }

    for message in log_messages {
        log(message);
    }
}

===== lib/src/dft_simulator.rs =====
use core::str;

use crate::{log, generate_cube_string};
use log::info;
use nalgebra::DMatrix;
use serde::{Deserialize, Serialize};
use crate::simulation::*;
use rustfft::{num_complex::Complex, FftPlanner};
use statrs::function::erf::erfc;
use lazy_static::lazy_static;
use std::sync::Mutex;


lazy_static! {
    pub static ref TOLERANCE: Mutex<f32> = Mutex::new(1e-9);
}

const MAX_ITERATIONS:usize = 100;
const EXCHANGE_CORRELATION_CONSTANT: f32 = -0.738558766;
pub const BOX_LENGTH: f32 = 8.0;


#[derive(Debug, Serialize, Deserialize)]
pub struct DFTSolver {
    pub final_density: Vec<f32>,
    pub eigenvalues: Option<Vec<f32>>,
}

impl DFTSolver {
    pub fn new() -> Self {
        DFTSolver {
            final_density: Vec::new(),
            eigenvalues: None,
        }
    }

    pub fn build_grid(&self, points_per_axis: usize) -> Vec<[f32; 3]> {
        let mut grid = Vec::with_capacity(points_per_axis * points_per_axis * points_per_axis);
        for x in 0..points_per_axis {
            let half = BOX_LENGTH / 2.0;
            let xf   = -half + BOX_LENGTH * (x as f32 / (points_per_axis as f32 - 1.0));
            for y in 0..points_per_axis {
                let yf = -half + BOX_LENGTH * (y as f32 / (points_per_axis as f32 - 1.0));
                for z in 0..points_per_axis {
                    let zf = -half + BOX_LENGTH * (z as f32 / (points_per_axis as f32 - 1.0));
                    grid.push([xf, yf, zf]);
                }
            }
        }
        grid
    }

    /// Run the self-consistent field (SCF) simulation.
    pub fn run_scf(&mut self, config: &SimulationConfig) {
        let points_per_axis = config.points_per_axis;
        let grid = self.build_grid(points_per_axis);
        let (atom_centers, atom_charges): (Vec<[f32; 3]>, Vec<f32>) = config
            .nuclei
            .iter()
            .map(|n| ([n.coordinates[0] as f32, n.coordinates[1] as f32, n.coordinates[2] as f32], n.atomic_number as f32))
            .unzip();
        *TOLERANCE.lock().unwrap() = config.tolerance;

        let (density, eigenvalues) = scf_loop(
            &grid,
            points_per_axis,
            &config.basis,
            config.num_electrons,
            &atom_centers,
            &atom_charges,
        );
        self.final_density = density;
        self.eigenvalues = eigenvalues;
    }
}

impl Clone for DFTSolver {
    fn clone(&self) -> Self {
        DFTSolver {
            final_density: self.final_density.clone(),
            eigenvalues: self.eigenvalues.clone(),
        }
    }
}

pub fn volume_element(points_per_axis: usize) -> f32 {
    let n = points_per_axis as f32;
    let delta = BOX_LENGTH / (n - 1.0);
    return delta.powi(3);
}


fn build_overlap_matrix(
    grid: &[[f32; 3]],
    basis: &[Box<dyn BasisFunction>],
    points_per_axis: usize,
) -> DMatrix<f32> {
    let n = basis.len();
    let mut s = DMatrix::<f32>::zeros(n, n);

    let dv = volume_element(points_per_axis);
    for i in 0..n {
        for j in 0..n {
            let mut sum = 0.0;
            for &pt in grid {
                sum += basis[i].value(&pt) * basis[j].value(&pt) * dv;
            }
            s[(i, j)] = sum;
        }
    }
    s
}

pub fn compute_hartree_potential_fft_padded(
    neutral_density: &[f32],
    points_per_axis: usize,
    pad: usize,
) -> Vec<f32> {
    let n = points_per_axis;
    let N = n + 2 * pad;
    let n3 = N * N * N;
    assert_eq!(neutral_density.len(), n*n*n,
        "Density len {} != {}³", neutral_density.len(), n);
    let delta = BOX_LENGTH / (n as f32 - 1.0);
    let dv = volume_element(points_per_axis as usize);

    log(format!("Padded FFT Poisson: {}³ → {}³ (pad={})", n, N, pad));

    // --- short‐range real‐space erfc sum on original grid ---
    let alpha = 3.0 / delta;
    let r_cut2 = (4.0 * delta).powi(2);
    let max_i = (r_cut2.sqrt() / delta).ceil() as isize;
    let mut neighbor = Vec::new();
    for dx in -max_i..=max_i {
        for dy in -max_i..=max_i {
            for dz in -max_i..=max_i {
                let r2 = (dx*dx + dy*dy + dz*dz) as f32;
                if r2 > 0.0 && r2 * delta * delta <= r_cut2 {
                    neighbor.push((dx, dy, dz, r2));
                }
            }
        }
    }
    let mut v_short = vec![0.0f32; n*n*n];
    let idx_opt = |x:isize, y:isize, z:isize| {
        if x<0 || x>=n as isize || y<0 || y>=n as isize || z<0 || z>=n as isize {
            None
        } else {
            Some((x as usize * n + y as usize) * n + z as usize)
        }
    };
    for ix in 0..n as isize {
        for iy in 0..n as isize {
            for iz in 0..n as isize {
                let dst = (ix as usize * n + iy as usize) * n + iz as usize;
                let mut sum = 0.0f32;
                for &(dx,dy,dz,r2) in &neighbor {
                    if let Some(src) = idx_opt(ix+dx, iy+dy, iz+dz) {
                        let r = r2.sqrt() * delta;
                        sum += neutral_density[src] * (erfc((alpha * r) as f64) / (r as f64)) as f32;
                    }
                }
                v_short[dst] = sum * dv;
            }
        }
    }

    // --- pack neutral_density * dv into padded complex array ---
    let mut data = vec![Complex::new(0.0,0.0); n3];
    for ix in 0..n {
        for iy in 0..n {
            for iz in 0..n {
                let src = (ix * n + iy) * n + iz;
                let dst = ((ix+pad) * N + (iy+pad)) * N + (iz+pad);
                data[dst] = Complex::new(neutral_density[src] * dv, 0.0);
            }
        }
    }

    // --- 3D FFT forward ---
    let mut planner = FftPlanner::<f32>::new();
    let fft = planner.plan_fft_forward(N);
    let ifft = planner.plan_fft_inverse(N);
    let idx3 = |i,j,k| ((i * N + j) * N + k) as usize;

    for i in 0..N {
        for j in 0..N {
            let mut row = (0..N).map(|k| data[idx3(i,j,k)]).collect::<Vec<_>>();
            fft.process(&mut row);
            for k in 0..N { data[idx3(i,j,k)] = row[k]; }
        }
    }
    for i in 0..N {
        for k in 0..N {
            let mut row = (0..N).map(|j| data[idx3(i,j,k)]).collect::<Vec<_>>();
            fft.process(&mut row);
            for j in 0..N { data[idx3(i,j,k)] = row[j]; }
        }
    }
    for j in 0..N {
        for k in 0..N {
            let mut row = (0..N).map(|i| data[idx3(i,j,k)]).collect::<Vec<_>>();
            fft.process(&mut row);
            for i in 0..N { data[idx3(i,j,k)] = row[i]; }
        }
    }

    // --- apply screened Green's function on padded box length ---
    let Lpad = BOX_LENGTH + 2.0 * pad as f32 * delta;
    let four_pi = 4.0 * std::f32::consts::PI;
    for i in 0..N {
        let ki = if i <= N/2 { i as f32 } else { i as f32 - N as f32 };
        let kx = two_pi() * ki / Lpad;
        for j in 0..N {
            let kj = if j <= N/2 { j as f32 } else { j as f32 - N as f32 };
            let ky = two_pi() * kj / Lpad;
            for k in 0..N {
                let kk = if k <= N/2 { k as f32 } else { k as f32 - N as f32 };
                let kz = two_pi() * kk / Lpad;
                let k2 = kx*kx + ky*ky + kz*kz;
                let gk = if k2 > 1e-12 {
                    four_pi / k2 * (-k2 / (4.0*alpha*alpha)).exp()
                } else { 0.0 };
                data[idx3(i,j,k)] *= Complex::new(gk, 0.0);
            }
        }
    }

    // --- inverse 3D FFT ---
    for j in 0..N {
        for k in 0..N {
            let mut row = (0..N).map(|i| data[idx3(i,j,k)]).collect::<Vec<_>>();
            ifft.process(&mut row);
            for i in 0..N { data[idx3(i,j,k)] = row[i]; }
        }
    }
    for i in 0..N {
        for k in 0..N {
            let mut row = (0..N).map(|j| data[idx3(i,j,k)]).collect::<Vec<_>>();
            ifft.process(&mut row);
            for j in 0..N { data[idx3(i,j,k)] = row[j]; }
        }
    }
    for i in 0..N {
        for j in 0..N {
            let mut row = (0..N).map(|k| data[idx3(i,j,k)]).collect::<Vec<_>>();
            ifft.process(&mut row);
            for k in 0..N { data[idx3(i,j,k)] = row[k]; }
        }
    }

    // --- crop back, normalize and combine ---
    let mut v = vec![0.0f32; n*n*n];
    for ix in 0..n {
        for iy in 0..n {
            for iz in 0..n {
                let src = ((ix+pad)*N + (iy+pad))*N + (iz+pad);
                let dst = (ix * n + iy) * n + iz;
                // inv_N3 applied implicitly by FFT library, dv already in data
                v[dst] = data[src].re + v_short[dst];
            }
        }
    }

    v
}

// two_pi helper
#[inline(always)]
fn two_pi() -> f32 {
    std::f32::consts::PI * 2.0
}

///// Pure direct‐sum Hartree (no FFT).  Very slow - only for diagnosis!
pub fn compute_hartree_potential_direct(
    density: &[f32],
    points_per_axis: usize,
) -> Vec<f32> {
    let n = points_per_axis;
    let N3 = n * n * n;
    assert_eq!(density.len(), N3,
        "Density len {} != {}³", density.len(), n);
    let delta = BOX_LENGTH / (n as f32 - 1.0);
    let dv = delta.powi(3);

    log(format!("Direct‐sum Poisson: {}³ grid, Δ={:.6}", n, delta));

    // collect coordinates of each grid point
    let mut coords = Vec::with_capacity(N3);
    for i in 0..n {
        let x = -BOX_LENGTH/2.0 + delta * (i as f32);
        for j in 0..n {
            let y = -BOX_LENGTH/2.0 + delta * (j as f32);
            for k in 0..n {
                let z = -BOX_LENGTH/2.0 + delta * (k as f32);
                coords.push([x, y, z]);
            }
        }
    }

    let mut v = vec![0.0f32; N3];
    for a in 0..N3 {
        let pa = coords[a];
        let mut sum = 0.0f32;
        for b in 0..N3 {
            if a == b { continue; }
            let pb = coords[b];
            let dx = pa[0] - pb[0];
            let dy = pa[1] - pb[1];
            let dz = pa[2] - pb[2];
            let r = (dx*dx + dy*dy + dz*dz).sqrt().max(1e-6);
            sum += density[b] * (1.0 / r);
        }
        v[a] = sum * dv;
    }

    v
}

// Numerical approximation of laplacian
// TODO: Analytic integrals might be better here (nevermind)
pub fn build_kinetic_matrix(
    grid: &[[f32; 3]],
    points_per_axis: usize,
    basis: &[Box<dyn BasisFunction>],
) -> DMatrix<f32> {
    let n_basis = basis.len();
    let n = points_per_axis;
    let delta = BOX_LENGTH / (n as f32 - 1.0);
    let dv = volume_element(points_per_axis);

    let ngrid = grid.len();

    let mut vals: Vec<Vec<f32>> = vec![vec![0.0f32; ngrid]; n_basis];
    for (bi, b) in basis.iter().enumerate() {
        for (idx, pt) in grid.iter().enumerate() {
            vals[bi][idx] = b.value(pt);
        }
    }

    let idx3 = |ix: usize, iy: usize, iz: usize| -> usize { (ix * n + iy) * n + iz };

    let mut lap: Vec<Vec<f32>> = vec![vec![0.0f32; ngrid]; n_basis];

    if n >= 3 {
        for ix in 1..(n - 1) {
            for iy in 1..(n - 1) {
                for iz in 1..(n - 1) {
                    let idx = idx3(ix, iy, iz);
                    for bi in 0..n_basis {
                        let center = vals[bi][idx];
                        let lap_x = vals[bi][idx3(ix + 1, iy, iz)] - 2.0 * center + vals[bi][idx3(ix - 1, iy, iz)];
                        let lap_y = vals[bi][idx3(ix, iy + 1, iz)] - 2.0 * center + vals[bi][idx3(ix, iy - 1, iz)];
                        let lap_z = vals[bi][idx3(ix, iy, iz + 1)] - 2.0 * center + vals[bi][idx3(ix, iy, iz - 1)];
                        lap[bi][idx] = (lap_x + lap_y + lap_z) / (delta * delta);
                    }
                }
            }
        }
    }

    let mut t = DMatrix::<f32>::zeros(n_basis, n_basis);
    for i in 0..n_basis {
        for j in 0..n_basis {
            let mut sum = 0.0f32;
            for idx in 0..ngrid {
                // note: lap[j][idx] is zero at boundaries; this is a simple approach
                sum += vals[i][idx] * (-0.5f32 * lap[j][idx]) * dv;
            }
            t[(i, j)] = sum;
        }
    }

    // sanity checks
    #[cfg(debug_assertions)]
    {
        let mut max_sym_diff = 0.0f32;
        for i in 0..n_basis {
            for j in 0..n_basis {
                max_sym_diff = max_sym_diff.max((t[(i, j)] - t[(j, i)]).abs());
            }
        }
        log(format!("build_kinetic_matrix: trace(T) = {:.6}, max |T-T^T| = {:.3e}", t.trace(), max_sym_diff));
    }

    t
}


pub fn build_full_hamiltonian(
    grid: &[[f32; 3]],
    points_per_axis: usize,
    basis: &[Box<dyn BasisFunction>],
    atomic_centers: &[[f32; 3]],
    atomic_charges: &[f32],
    neutral_density: &[f32],
) -> DMatrix<f32> {
    let n = basis.len();
    let mut h = DMatrix::<f32>::zeros(n, n);

    let dv = volume_element(points_per_axis);

    // Hartree potential on grid (FFT padded).
    let v_h = compute_hartree_potential_fft_padded(neutral_density, points_per_axis, 1);
    // let v_h = compute_hartree_potential_direct(neutral_density, points_per_axis);

    // Build kinetic matrix T_ij once (finite-difference projection).
    let t_mat = build_kinetic_matrix(grid, points_per_axis, basis);

    // Loop over basis functions and build potential part of H,
    // then add kinetic contribution from t_mat.
    for i in 0..n {
        for j in 0..n {
            let mut hij_pot = 0.0f32;
            for (k_idx, &pt) in grid.iter().enumerate() {
                let phi_i = basis[i].value(&pt);
                let phi_j = basis[j].value(&pt);

                // nuclear attraction: - sum_a Z_a / |r - R_a|
                let v_nuc = atomic_centers
                    .iter()
                    .zip(atomic_charges.iter())
                    .map(|(ac, &q)| {
                        let dx = pt[0] - ac[0];
                        let dy = pt[1] - ac[1];
                        let dz = pt[2] - ac[2];
                        // protect against r->0 on grid: use small floor
                        let r = dx.hypot(dy).hypot(dz).max(1e-6);
                        -q / r
                    })
                    .sum::<f32>();

                // exchange-correlation (simple local form you already use)
                let rho = neutral_density[k_idx].max(1e-12);
                let v_xc = EXCHANGE_CORRELATION_CONSTANT * rho.powf(1.0 / 3.0);

                // effective potential at grid point
                let v_eff = v_nuc + v_h[k_idx] + v_xc;

                hij_pot += phi_i * v_eff * phi_j * dv;
            }

            // Add kinetic matrix element (T_ij) to potential integral.
            // The kinetic matrix already implements (-1/2 ∇²) projection.
            let tij = t_mat[(i, j)];
            h[(i, j)] = tij + hij_pot;
        }
    }

    // IMPORTANT: Enforce hermiticity (symmetrize) to remove tiny numerical asymmetry:
    // H = 0.5 * (H + H^T)
    let h_transpose = h.transpose();
    let h_sym = (&h + &h_transpose) * 0.5;
    // Copy back
    for i in 0..n {
        for j in 0..n {
            h[(i, j)] = h_sym[(i, j)];
        }
    }

    h
}

/// Update the electron density on the grid from the occupied eigenfunctions.
fn update_density(
    grid: &[[f32; 3]],
    eigenvectors: &DMatrix<f32>,
    basis: &[Box<dyn BasisFunction>],
    num_electrons: usize,
) -> Vec<f32> {
    let n_grid = grid.len() as f32;
    let vol = BOX_LENGTH.powi(3);
    let dv = vol / n_grid;
    let n_occ = num_electrons.min(eigenvectors.ncols());
    let mut density = vec![0.0; n_grid as usize];

    for (k, &pt) in grid.iter().enumerate() {
        let mut ρ_sum = 0.0;
        for occ in 0..n_occ {
            let mut ψ = 0.0;
            for b in 0..basis.len() {
                ψ += eigenvectors[(b, occ)] * basis[b].value(&pt);
            }
            ρ_sum += ψ * ψ;
        }
        density[k] = ρ_sum;
    }

    // Drift correction: normalize the density to match the number of electrons
    let total_raw: f32 = density.iter().sum();
    let physical_total = total_raw * dv;
    let n_e = num_electrons as f32;
    if physical_total > 1e-12 {
        let scale = n_e / physical_total;
        for d in &mut density {
            *d *= scale;
        }
    }
    density
}

/// The self-consistent field (SCF) loop.
/// 1. Build the neutralized density,
/// 2. Build the Hamiltonian,
/// 3. Diagonalize it,
/// 4. Update the electron density,
/// 5. Apply mixing, and
/// 6. Check for convergence.
fn scf_loop(
    grid: &[[f32; 3]],
    points_per_axis: usize,
    basis: &[Box<dyn BasisFunction>],
    num_electrons: usize,
    atomic_centers: &[[f32; 3]],
    atomic_charges: &[f32],
) -> (Vec<f32>, Option<Vec<f32>>) {
    // Initialize with a uniform density: n_e / volume
    let initial_density_value = num_electrons as f32 / BOX_LENGTH.powi(3);
    let mut density = vec![initial_density_value; grid.len()];

    for iter in 0..MAX_ITERATIONS {
        log(format!("SCF iteration {}", iter + 1));

        // 1) Build neutralized density (ρ - ρ_bg)
        let vol = BOX_LENGTH.powi(3);
        let dv = vol / (grid.len() as f32);
        let n_e: f32 = density.iter().map(|&ρ| ρ * dv).sum();
        let z: f32 = atomic_charges.iter().sum();
        let rho_bg = (n_e - z) / vol;
        let mut neutral_density = Vec::with_capacity(density.len());
        for &value in &density {
            neutral_density.push(value - rho_bg);
        }
        log(format!(
            " SCF iter {}: N_e={:.6}, Z={:.6}, ρ_bg={:.3e}",
            iter + 1,
            n_e,
            z,
            rho_bg
        ));

        // 2) Build H and S
        let h = build_full_hamiltonian(
            grid,
            points_per_axis,
            basis,
            atomic_centers,
            atomic_charges,
            &neutral_density,
        );
        let s = build_overlap_matrix(grid, basis, points_per_axis);

        // 3) Solve generalized eigenproblem H C = S C ε
        let l_factor = s.clone().cholesky().expect("Overlap not positive-definite").l();
        let linv = l_factor.clone().try_inverse().unwrap();
        let ht = &linv * &h * &linv.transpose();
        let eig = ht.symmetric_eigen();
        let c = linv.transpose() * eig.eigenvectors;

        ////// Diagnostics ////

        let m = (&c.transpose() * &s) * &c;
        let (rows, cols) = m.shape();
        for i in 0..rows {
            for j in 0..cols {
                info!("M[{},{}] = {:.3e}", i, j, m[(i,j)]);
            }
        }

        for (k,&ev) in eig.eigenvalues.iter().enumerate() {
            info!("  ε[{}] = {:.6}", k, ev);
        }

        for (i, b) in basis.iter().enumerate() {
            if let Some(gauss) = b.as_any().downcast_ref::<AngularGaussian>() {
                info!(
                    "Basis[{}] at {:?}, l=({},{},{}), alpha={}",
                    i, gauss.center, gauss.l.0, gauss.l.1, gauss.l.2, gauss.alpha
                );
            } else {
                info!("Basis[{}] is not an AngularGaussian, skipping...", i);
            }
        }

        let mut max_diff = 0.0f32;
        for i in 0..h.nrows() { for j in 0..h.ncols() {
            max_diff = max_diff.max((h[(i,j)] - h[(j,i)]).abs());
        }}
        log(format!("max |H - H^T| = {}", max_diff));

        let s_eig = s.symmetric_eigen();
        log(format!("S eigenvalues: {:?}", s_eig.eigenvalues));

        ///////////////////

        // 4) Update density from occupied eigenvectors
        let new_density = update_density(grid, &c, basis, num_electrons);

        // 5) Simple linear mixing
        let alpha = 0.2;
        let mut diff = 0.0;
        for (d_old, &d_new) in density.iter_mut().zip(&new_density) {
            diff += (d_new - *d_old).abs();
            *d_old = alpha * d_new + (1.0 - alpha) * *d_old;
        }

        log(String::from(format!(" SCF iter {}: Density updated, diff={:.3e}", iter + 1, diff)));

        // 6) Check for convergence
        if diff < *TOLERANCE.lock().unwrap() {
            log(format!("Converged in {} iterations", iter + 1));
            return (density, Some(eig.eigenvalues.iter().cloned().collect()));
        }
    }

    log("SCF did not converge".to_string());
    (density, None)
}

pub fn run_scf_command(args: Vec<String>) {
    if args.len() != 1 {
        log("Usage: run_dft <config>".into());
        return;
    }
    let key = &args[0];
    let cfgs = SIMULATION_CONFIGS.lock().unwrap();
    let cfg = match cfgs.get(key) {
        Some(c) => c.clone(),
        None => {
            log(format!("Unknown config '{}'", key));
            if !cfgs.is_empty() {
                log(format!(
                    "Available configs: {}",
                    cfgs.keys().cloned().collect::<Vec<_>>().join(", ")
                ));
            }
            return;
        }
    };

    log(format!("Running SCF on '{}'", key));
    let mut solver = DFTSolver::new();
    solver.run_scf(&cfg);

    *SIMULATION_STATE.lock().unwrap() =
        SimulationState::new(0.0, solver.clone(), SimulationStatus::Completed);

    log("SCF complete".into());

    info!("{}", generate_cube_string(&solver.final_density, cfg.points_per_axis, BOX_LENGTH));
}
===== lib/src/lib.rs =====
#![allow(special_module_name)]

pub mod commands;
pub mod renderer;
pub mod simulation;
pub mod dft_simulator;

use wasm_bindgen::prelude::*;

use web_sys::HtmlElement;
use log::info;
use three_d::renderer::*;
use std::fmt::Write;

#[cfg(target_arch = "wasm32")]
#[wasm_bindgen(start)]
pub fn start() -> Result<(), JsValue> {
    console_log::init_with_level(log::Level::Debug).unwrap();
    info!("Logging works!");
    std::panic::set_hook(Box::new(console_error_panic_hook::hook));
    register_commands();
    renderer::main();
    Ok(())
}

#[wasm_bindgen]
pub fn log(message: String) {
    info!("{}", message);
    let document = web_sys::window().unwrap().document().unwrap();
    let log_area = document.get_element_by_id("log-area")
        .unwrap()
        .dyn_into::<HtmlElement>()
        .unwrap();
    let timestamp = js_sys::Date::new_0().to_locale_time_string("en-GB");
    let formatted_message = format!("[{}] {}", timestamp, message);
    log_area.set_inner_html(&format!("{}<br>{}", log_area.inner_html(), formatted_message));
    log_area.set_scroll_top(log_area.scroll_height());  // This scrolls to the bottom
}

pub fn register_commands() {
    register_command!("reset_camera", reset_camera_command, "Reset camera to default settings", "reset_camera");
    register_command!("fov", update_camera_fov_command, "Update camera field of view (FOV)", "fov [degrees]");
    register_command!("run_dft", dft_simulator::run_scf_command, "Run self-consistent field (SCF) simulation of KS-DFT", "run_dft <config>");
    commands::init();
}

fn reset_camera_command(args: Vec<String>) {
    if args.len() != 0 {
        log(format!("Invalid number of arguments for reset_camera_command"));
        return;
    }
    log(format!("Resetting camera to default settings"));
    if let Some(camera) = renderer::CAMERA_INSTANCE.lock().unwrap().as_mut() {
        let default_position = vec3(0.0, 2.0, 4.0);
        let default_target = vec3(0.0, 0.0, 0.0);
        let default_up = vec3(0.0, 1.0, 0.0);
        let default_fov = 45.0;
        let default_z_near = 0.1;
        let default_z_far = 100.0;
        *camera = Camera::new_perspective(
            camera.viewport().clone(),
            default_position,
            default_target,
            default_up,
            degrees(default_fov),
            default_z_near,
            default_z_far,
        );
        log(format!("Camera reset to default position: {:?}, target: {:?}, FOV: {} degrees",
            default_position, default_target, default_fov));
    } else {
        log(format!("Camera instance not initialized"));
    }
}

fn update_camera_fov_command(args: Vec<String>) {
    if args.len() != 1 {
        log(format!("Invalid number of arguments for update_camera_fov_command"));
        return;
    }

    match args[0].parse::<f32>() {
        Ok(fov_degrees) if fov_degrees > 0.0 && fov_degrees < 180.0 => {
            if let Some(camera) = renderer::CAMERA_INSTANCE.lock().unwrap().as_mut() {
                let current_viewport = camera.viewport().clone();
                let current_position = *camera.position();
                let current_target = *camera.target();
                let current_up = *camera.up();
                let current_z_near = camera.z_near();
                let current_z_far = camera.z_far();

                *camera = Camera::new_perspective(
                    current_viewport,
                    current_position,
                    current_target,
                    current_up,
                    degrees(fov_degrees),
                    current_z_near,
                    current_z_far,
                );

                log(format!("Camera FOV updated to {} degrees", fov_degrees));
            } else {
                log(format!("Camera instance not initialized"));
            }
        }
        _ => {
            log(format!("Invalid FOV value: {:?}", args[0]));
        }
    }
}

#[wasm_bindgen]
pub fn handle_command(command_line: &str) {
    let parts: Vec<&str> = command_line.split_whitespace().collect();
    if parts.is_empty() {
        log(format!("No command entered"));
        return;
    }
    let command_name = parts[0];
    let args: Vec<String> = parts[1..].iter().map(|&s| s.to_string()).collect();

    let registry_clone = {
        let registry = commands::COMMAND_REGISTRY.lock().unwrap();
        registry.clone()
    };

    if let Some(command) = registry_clone.get(command_name) {
        (command.func)(args);
    } else {
        log(format!("Command not found: {}", command_name));
    }
}

//This will always output in the console for diagnosis with https://www.openmx-square.org/viewer/
//NOTE: it will not be centered as that is applied in the rendering pipeline
pub fn generate_cube_string(
    density: &[f32],
    points_per_axis: usize,
    box_length: f32,
) -> String {
    let mut output = String::new();
    let n = points_per_axis;
    let delta = box_length / (n as f32 - 1.0);

    writeln!(&mut output, "Electron density").unwrap();
    writeln!(&mut output, "Generated from DFTSolver output").unwrap();
    writeln!(&mut output, "{:5} {:10.6} {:10.6} {:10.6}", 1, 0.0, 0.0, 0.0).unwrap();
    writeln!(&mut output, "{:5} {:.6}  {:.6}  {:.6}", n, delta, 0.0, 0.0).unwrap();
    writeln!(&mut output, "{:5} {:.6}  {:.6}  {:.6}", n, 0.0, delta, 0.0).unwrap();
    writeln!(&mut output, "{:5} {:.6}  {:.6}  {:.6}", n, 0.0, 0.0, delta).unwrap();
    writeln!(&mut output, "{:5} {:10.6} {:10.6} {:10.6}  {:>2}", 0, 0.0, 0.0, 0.0, 0).unwrap();

    for x in 0..n {
        for y in 0..n {
            for z in 0..n {
                let idx = (x * n + y) * n + z;
                write!(&mut output, "{:13.6e}", density[idx]).unwrap();
                if (z % 6) == 5 {
                    writeln!(&mut output).unwrap();
                }
            }
        }
    }

    output
}
===== lib/src/renderer.rs =====
use std::sync::Mutex;
use lazy_static::lazy_static;
use three_d::{renderer::*, FrameInputGenerator, SurfaceSettings, WindowedContext};
use log::info;
use crate::simulation::*;
use crate::dft_simulator::*;

lazy_static! {
    pub static ref CAMERA_INSTANCE: Mutex<Option<Camera>> = Mutex::new(None);
    pub static ref CASHED_CPU_MESH: Mutex<CpuMesh> = Mutex::new(CpuMesh::default());
    pub static ref FRAME_COUNTER: Mutex<u32> = Mutex::new(0);
}

pub fn main() {
    let event_loop = winit::event_loop::EventLoop::new();

    #[cfg(not(target_arch = "wasm32"))]
    let window_builder = winit::window::WindowBuilder::new()
        .with_title("Full-Screen Window")
        .with_inner_size(winit::dpi::LogicalSize::new(1920, 1080))
        .with_decorations(false)
        .with_maximized(true);

    #[cfg(target_arch = "wasm32")]
    let window_builder = {
        use wasm_bindgen::JsCast;
        use winit::platform::web::WindowBuilderExtWebSys;
        let window = web_sys::window().unwrap();
        let document = window.document().unwrap();
        let canvas = document
            .get_element_by_id("canvas")
            .unwrap()
            .dyn_into::<web_sys::HtmlCanvasElement>()
            .unwrap();
        let width = canvas.client_width() as f64;
        let height = canvas.client_height() as f64;

        winit::window::WindowBuilder::new()
            .with_canvas(Some(canvas))
            .with_inner_size(winit::dpi::LogicalSize::new(width, height))
            .with_prevent_default(true)
    };

    let window = window_builder.build(&event_loop).unwrap();
    let context =
        WindowedContext::from_winit_window(&window, SurfaceSettings::default()).unwrap();

    let camera = Camera::new_perspective(
        Viewport::new_at_origo(1, 1),
        vec3(0.0, 2.0, 4.0),
        vec3(0.0, 0.0, 0.0),
        vec3(0.0, 1.0, 0.0),
        degrees(45.0),
        0.1,
        1000.0,
    );

    *CAMERA_INSTANCE.lock().unwrap() = Some(camera.clone());

    let mut control = OrbitControl::new(*camera.target(), 1.0, 100.0);

    let mut frame_input_generator = FrameInputGenerator::from_winit_window(&window);

    event_loop.run(move |event, _, control_flow| {
        match event {
            winit::event::Event::MainEventsCleared => {
                window.request_redraw();
            }
            winit::event::Event::RedrawRequested(_) => {
                {
                    let mut frame_count = FRAME_COUNTER.lock().unwrap();
                    *frame_count += 1;
                    if *frame_count % 60 == 0 {
                        let cpu_mesh = generate_mesh_from_density();
                        info!("Generated mesh!");
                        let mut cached = CASHED_CPU_MESH.try_lock().unwrap();
                        cached.clone_from(&cpu_mesh);
                    }
                }

                let mesh_model: Gm<Mesh, ColorMaterial> = Gm::new(
                    Mesh::new(&context, &CASHED_CPU_MESH.lock().unwrap()),
                    ColorMaterial {
                        color: Srgba::GREEN,
                        ..Default::default()
                    },
                );
                
                let mut frame_input: three_d::FrameInput = frame_input_generator.generate(&context);

                if let Some(camera) = CAMERA_INSTANCE.lock().unwrap().as_mut() {
                    control.handle_events(camera, &mut frame_input.events);
                    camera.set_viewport(frame_input.viewport);
                    frame_input
                        .screen()
                        .clear(ClearState::color_and_depth(0.8, 0.8, 0.8, 1.0, 1.0))
                        .render(camera, &mesh_model, &[]);
                }

                context.swap_buffers().unwrap();
                control_flow.set_poll();
                window.request_redraw();
            }
            winit::event::Event::WindowEvent { ref event, .. } => {
                frame_input_generator.handle_winit_window_event(event);

                match event {
                    winit::event::WindowEvent::Resized(physical_size) => {
                        log::info!("Resized to {:?}", physical_size);
                        context.resize(*physical_size);
                    }
                    winit::event::WindowEvent::ScaleFactorChanged { new_inner_size, .. } => {
                        context.resize(**new_inner_size);
                    }
                    winit::event::WindowEvent::CloseRequested => {
                        control_flow.set_exit();
                    }
                    _ => (),
                }
            }
            _ => {}
        }
    });
}

//fn generate_mesh_from_density() -> CpuMesh {
//
//    if let Ok(state) = SIMULATION_STATE.try_lock() {
//        if state.dft_simulator.final_density.is_empty() {
//            return CpuMesh::default();
//        }
//
//        let density = state.dft_simulator.final_density.clone();
//        let grid_size = (density.len() as f64).powf(1.0 / 3.0).round() as usize;
//        let iso_value = (*density.iter().min_by(|a, b| a.partial_cmp(b).unwrap()).unwrap()) * 1.1;
//
//        let mut vertices = Vec::new();
//        let mut indices: Vec<u32> = Vec::new();
//
//        fn vertex_interp(p1: Vec3, p2: Vec3, valp1: f32, valp2: f32, iso_value: f32) -> Vec3 {
//            if (iso_value - valp1).abs() < 0.00001 {
//                return p1;
//            }
//            if (iso_value - valp2).abs() < 0.00001 {
//                return p2;
//            }
//            if (valp1 - valp2).abs() < 0.00001 {
//                return p1;
//            }
//            let mu = (iso_value - valp1) / (valp2 - valp1);
//            p1 + (p2 - p1) * mu
//        }
//
//        let gsq = grid_size * grid_size;
//        let grid_size_usize = grid_size as usize;
//
//        for z in 0..(grid_size_usize - 1) {
//            for y in 0..(grid_size_usize - 1) {
//                for x in 0..(grid_size_usize - 1) {
//                    let x = x as usize;
//                    let y = y as usize;
//                    let z = z as usize;
//
//                    let cube_indices = [
//                        x     + y * grid_size_usize + z * gsq,
//                        x + 1 + y * grid_size_usize + z * gsq,
//                        x + 1 + (y + 1) * grid_size_usize + z * gsq,
//                        x     + (y + 1) * grid_size_usize + z * gsq,
//                        x     + y * grid_size_usize + (z + 1) * gsq,
//                        x + 1 + y * grid_size_usize + (z + 1) * gsq,
//                        x + 1 + (y + 1) * grid_size_usize + (z + 1) * gsq,
//                        x     + (y + 1) * grid_size_usize + (z + 1) * gsq,
//                    ];
//
//                    // Bounds check for safety (should not trigger, but helps debug)
//                    if cube_indices.iter().any(|&i| i >= density.len()) {
//                        continue;
//                    }
//
//                    let cube_positions = [
//                        vec3(x as f32, y as f32, z as f32),
//                        vec3((x + 1) as f32, y as f32, z as f32),
//                        vec3((x + 1) as f32, (y + 1) as f32, z as f32),
//                        vec3(x as f32, (y + 1) as f32, z as f32),
//                        vec3(x as f32, y as f32, (z + 1) as f32),
//                        vec3((x + 1) as f32, y as f32, (z + 1) as f32),
//                        vec3((x + 1) as f32, (y + 1) as f32, (z + 1) as f32),
//                        vec3(x as f32, (y + 1) as f32, (z + 1) as f32),
//                    ];
//
//                    let cube_values = [
//                        density[cube_indices[0]],
//                        density[cube_indices[1]],
//                        density[cube_indices[2]],
//                        density[cube_indices[3]],
//                        density[cube_indices[4]],
//                        density[cube_indices[5]],
//                        density[cube_indices[6]],
//                        density[cube_indices[7]],
//                    ];
//
//                    let mut cube_index = 0;
//                    if cube_values[0] < iso_value { cube_index |= 1; }
//                    if cube_values[1] < iso_value { cube_index |= 2; }
//                    if cube_values[2] < iso_value { cube_index |= 4; }
//                    if cube_values[3] < iso_value { cube_index |= 8; }
//                    if cube_values[4] < iso_value { cube_index |= 16; }
//                    if cube_values[5] < iso_value { cube_index |= 32; }
//                    if cube_values[6] < iso_value { cube_index |= 64; }
//                    if cube_values[7] < iso_value { cube_index |= 128; }
//
//                    if EDGE_TABLE[cube_index] == 0 {
//                        continue;
//                    }
//
//                    let mut vert_list: [Vec3; 12] = [vec3(0.0, 0.0, 0.0); 12];
//                    if (EDGE_TABLE[cube_index] & 1) != 0 {
//                        vert_list[0] = vertex_interp(cube_positions[0], cube_positions[1], cube_values[0], cube_values[1], iso_value);
//                    }
//                    if (EDGE_TABLE[cube_index] & 2) != 0 {
//                        vert_list[1] = vertex_interp(cube_positions[1], cube_positions[2], cube_values[1], cube_values[2], iso_value);
//                    }
//                    if (EDGE_TABLE[cube_index] & 4) != 0 {
//                        vert_list[2] = vertex_interp(cube_positions[2], cube_positions[3], cube_values[2], cube_values[3], iso_value);
//                    }
//                    if (EDGE_TABLE[cube_index] & 8) != 0 {
//                        vert_list[3] = vertex_interp(cube_positions[3], cube_positions[0], cube_values[3], cube_values[0], iso_value);
//                    }
//                    if (EDGE_TABLE[cube_index] & 16) != 0 {
//                        vert_list[4] = vertex_interp(cube_positions[4], cube_positions[5], cube_values[4], cube_values[5], iso_value);
//                    }
//                    if (EDGE_TABLE[cube_index] & 32) != 0 {
//                        vert_list[5] = vertex_interp(cube_positions[5], cube_positions[6], cube_values[5], cube_values[6], iso_value);
//                    }
//                    if (EDGE_TABLE[cube_index] & 64) != 0 {
//                        vert_list[6] = vertex_interp(cube_positions[6], cube_positions[7], cube_values[6], cube_values[7], iso_value);
//                    }
//                    if (EDGE_TABLE[cube_index] & 128) != 0 {
//                        vert_list[7] = vertex_interp(cube_positions[7], cube_positions[4], cube_values[7], cube_values[4], iso_value);
//                    }
//                    if (EDGE_TABLE[cube_index] & 256) != 0 {
//                        vert_list[8] = vertex_interp(cube_positions[0], cube_positions[4], cube_values[0], cube_values[4], iso_value);
//                    }
//                    if (EDGE_TABLE[cube_index] & 512) != 0 {
//                        vert_list[9] = vertex_interp(cube_positions[1], cube_positions[5], cube_values[1], cube_values[5], iso_value);
//                    }
//                    if (EDGE_TABLE[cube_index] & 1024) != 0 {
//                        vert_list[10] = vertex_interp(cube_positions[2], cube_positions[6], cube_values[2], cube_values[6], iso_value);
//                    }
//                    if (EDGE_TABLE[cube_index] & 2048) != 0 {
//                        vert_list[11] = vertex_interp(cube_positions[3], cube_positions[7], cube_values[3], cube_values[7], iso_value);
//                    }
//
//                    let mut i = 0;
//                    while TRI_TABLE[cube_index][i] != -1 {
//                        let index0 = TRI_TABLE[cube_index][i] as usize;
//                        let index1 = TRI_TABLE[cube_index][i + 1] as usize;
//                        let index2 = TRI_TABLE[cube_index][i + 2] as usize;
//
//                        let base_index = vertices.len() as u32;
//                        vertices.push(vert_list[index0]);
//                        vertices.push(vert_list[index1]);
//                        vertices.push(vert_list[index2]);
//
//                        indices.push(base_index);
//                        indices.push(base_index + 1);
//                        indices.push(base_index + 2);
//
//                        i += 3;
//                    }
//                }
//            }
//        }
//
//        let vertex_vectors: Vec<Vector3<f32>> = vertices
//            .into_iter()
//            .map(|v| Vector3::new(v[0], v[1], v[2]))
//            .collect();
//
//        let positions = Positions::F32(vertex_vectors);
//
//        let mesh = CpuMesh {
//            positions,
//            indices: Indices::U32(indices.into_iter().map(|i| i as u32).collect()),
//            ..Default::default()
//        };
//
//        return mesh;
//    } else {
//        return CpuMesh::default();
//    }
//}

fn generate_mesh_from_density() -> CpuMesh {
    if let Ok(state) = SIMULATION_STATE.try_lock() {
        if state.dft_simulator.final_density.is_empty() {
            return CpuMesh::default();
        }

        let density = state.dft_simulator.final_density.clone();
        let grid_size = (density.len() as f64).powf(1.0 / 3.0).round() as usize;
        if grid_size < 2 {
            return CpuMesh::default();
        }

        // physical grid spacing and half-extent
        let n = grid_size as f32;
        let delta = BOX_LENGTH / (n - 1.0);
        let half = BOX_LENGTH / 2.0;
        let dv = volume_element(grid_size);

        // compute center-of-mass (physical coordinates) of the density
        let mut n_calc = 0.0f32;
        let mut rcm = vec3(0.0f32, 0.0f32, 0.0f32);
        let gsq = grid_size * grid_size;
        for z in 0..grid_size {
            for y in 0..grid_size {
                for x in 0..grid_size {
                    let idx = x + y * grid_size + z * gsq;
                    let rho = density[idx];
                    let px = (x as f32) * delta - half;
                    let py = (y as f32) * delta - half;
                    let pz = (z as f32) * delta - half;
                    n_calc += rho * dv;
                    rcm += vec3(px, py, pz) * (rho * dv);
                }
            }
        }
        let r_cm = if n_calc.abs() > 1e-12 {
            rcm / n_calc
        } else {
            vec3(0.0, 0.0, 0.0)
        };

        // compute iso value (same heuristic you used)
        let min_val = *density
            .iter()
            .min_by(|a, b| a.partial_cmp(b).unwrap())
            .unwrap_or(&0.0);
        let iso_value = min_val * 1.1_f32;

        let mut vertices = Vec::new();
        let mut indices: Vec<u32> = Vec::new();

        // linear interpolation helper (keeps your original behavior)
        fn vertex_interp(p1: Vec3, p2: Vec3, valp1: f32, valp2: f32, iso_value: f32) -> Vec3 {
            if (iso_value - valp1).abs() < 0.00001 {
                return p1;
            }
            if (iso_value - valp2).abs() < 0.00001 {
                return p2;
            }
            if (valp1 - valp2).abs() < 0.00001 {
                return p1;
            }
            let mu = (iso_value - valp1) / (valp2 - valp1);
            p1 + (p2 - p1) * mu
        }

        // march cubes over cells: Note we use physical positions and subtract r_cm
        for z in 0..(grid_size - 1) {
            for y in 0..(grid_size - 1) {
                for x in 0..(grid_size - 1) {
                    let x_u = x as usize;
                    let y_u = y as usize;
                    let z_u = z as usize;

                    // indices into flattened density array (x fastest)
                    let cube_indices = [
                        x_u + y_u * grid_size + z_u * gsq,
                        x_u + 1 + y_u * grid_size + z_u * gsq,
                        x_u + 1 + (y_u + 1) * grid_size + z_u * gsq,
                        x_u + (y_u + 1) * grid_size + z_u * gsq,
                        x_u + y_u * grid_size + (z_u + 1) * gsq,
                        x_u + 1 + y_u * grid_size + (z_u + 1) * gsq,
                        x_u + 1 + (y_u + 1) * grid_size + (z_u + 1) * gsq,
                        x_u + (y_u + 1) * grid_size + (z_u + 1) * gsq,
                    ];

                    // safety
                    if cube_indices.iter().any(|&i| i >= density.len()) {
                        continue;
                    }

                    // corner positions in physical coords, shifted by r_cm to recenter mesh
                    let corner = |xi: usize, yi: usize, zi: usize| -> Vec3 {
                        let px = (xi as f32) * delta - half - r_cm.x;
                        let py = (yi as f32) * delta - half - r_cm.y;
                        let pz = (zi as f32) * delta - half - r_cm.z;
                        vec3(px, py, pz)
                    };

                    let cube_positions = [
                        corner(x_u, y_u, z_u),
                        corner(x_u + 1, y_u, z_u),
                        corner(x_u + 1, y_u + 1, z_u),
                        corner(x_u, y_u + 1, z_u),
                        corner(x_u, y_u, z_u + 1),
                        corner(x_u + 1, y_u, z_u + 1),
                        corner(x_u + 1, y_u + 1, z_u + 1),
                        corner(x_u, y_u + 1, z_u + 1),
                    ];

                    let cube_values = [
                        density[cube_indices[0]],
                        density[cube_indices[1]],
                        density[cube_indices[2]],
                        density[cube_indices[3]],
                        density[cube_indices[4]],
                        density[cube_indices[5]],
                        density[cube_indices[6]],
                        density[cube_indices[7]],
                    ];

                    let mut cube_index = 0;
                    if cube_values[0] < iso_value { cube_index |= 1; }
                    if cube_values[1] < iso_value { cube_index |= 2; }
                    if cube_values[2] < iso_value { cube_index |= 4; }
                    if cube_values[3] < iso_value { cube_index |= 8; }
                    if cube_values[4] < iso_value { cube_index |= 16; }
                    if cube_values[5] < iso_value { cube_index |= 32; }
                    if cube_values[6] < iso_value { cube_index |= 64; }
                    if cube_values[7] < iso_value { cube_index |= 128; }

                    if EDGE_TABLE[cube_index] == 0 {
                        continue;
                    }

                    let mut vert_list: [Vec3; 12] = [vec3(0.0, 0.0, 0.0); 12];
                    if (EDGE_TABLE[cube_index] & 1) != 0 {
                        vert_list[0] = vertex_interp(cube_positions[0], cube_positions[1], cube_values[0], cube_values[1], iso_value);
                    }
                    if (EDGE_TABLE[cube_index] & 2) != 0 {
                        vert_list[1] = vertex_interp(cube_positions[1], cube_positions[2], cube_values[1], cube_values[2], iso_value);
                    }
                    if (EDGE_TABLE[cube_index] & 4) != 0 {
                        vert_list[2] = vertex_interp(cube_positions[2], cube_positions[3], cube_values[2], cube_values[3], iso_value);
                    }
                    if (EDGE_TABLE[cube_index] & 8) != 0 {
                        vert_list[3] = vertex_interp(cube_positions[3], cube_positions[0], cube_values[3], cube_values[0], iso_value);
                    }
                    if (EDGE_TABLE[cube_index] & 16) != 0 {
                        vert_list[4] = vertex_interp(cube_positions[4], cube_positions[5], cube_values[4], cube_values[5], iso_value);
                    }
                    if (EDGE_TABLE[cube_index] & 32) != 0 {
                        vert_list[5] = vertex_interp(cube_positions[5], cube_positions[6], cube_values[5], cube_values[6], iso_value);
                    }
                    if (EDGE_TABLE[cube_index] & 64) != 0 {
                        vert_list[6] = vertex_interp(cube_positions[6], cube_positions[7], cube_values[6], cube_values[7], iso_value);
                    }
                    if (EDGE_TABLE[cube_index] & 128) != 0 {
                        vert_list[7] = vertex_interp(cube_positions[7], cube_positions[4], cube_values[7], cube_values[4], iso_value);
                    }
                    if (EDGE_TABLE[cube_index] & 256) != 0 {
                        vert_list[8] = vertex_interp(cube_positions[0], cube_positions[4], cube_values[0], cube_values[4], iso_value);
                    }
                    if (EDGE_TABLE[cube_index] & 512) != 0 {
                        vert_list[9] = vertex_interp(cube_positions[1], cube_positions[5], cube_values[1], cube_values[5], iso_value);
                    }
                    if (EDGE_TABLE[cube_index] & 1024) != 0 {
                        vert_list[10] = vertex_interp(cube_positions[2], cube_positions[6], cube_values[2], cube_values[6], iso_value);
                    }
                    if (EDGE_TABLE[cube_index] & 2048) != 0 {
                        vert_list[11] = vertex_interp(cube_positions[3], cube_positions[7], cube_values[3], cube_values[7], iso_value);
                    }

                    let mut i_tri = 0;
                    while TRI_TABLE[cube_index][i_tri] != -1 {
                        let index0 = TRI_TABLE[cube_index][i_tri] as usize;
                        let index1 = TRI_TABLE[cube_index][i_tri + 1] as usize;
                        let index2 = TRI_TABLE[cube_index][i_tri + 2] as usize;

                        let base_index = vertices.len() as u32;
                        vertices.push(vert_list[index0]);
                        vertices.push(vert_list[index1]);
                        vertices.push(vert_list[index2]);

                        indices.push(base_index);
                        indices.push(base_index + 1);
                        indices.push(base_index + 2);

                        i_tri += 3;
                    }
                }
            }
        }

        // convert to CpuMesh expected types (Vector3)
        let vertex_vectors: Vec<Vector3<f32>> = vertices
            .into_iter()
            .map(|v| Vector3::new(v.x, v.y, v.z))
            .collect();

        let positions = Positions::F32(vertex_vectors);

        let mesh = CpuMesh {
            positions,
            indices: Indices::U32(indices.into_iter().map(|i| i as u32).collect()),
            ..Default::default()
        };

        return mesh;
    } else {
        return CpuMesh::default();
    }
}

// Marching cubes lookup tables: SOURCE: https://github.com/TristanAntonsen/marching-cubes/blob/main/src/lib.rs //TODO ADD TO SOURCE TRACKER
const EDGE_TABLE: [i32; 256] = [
    0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03,
    0xe09, 0xf00, 0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f,
    0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
    0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6,
    0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569,
    0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69,
    0xb60, 0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6,
    0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c,
    0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf,
    0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, 0xac3,
    0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
    0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55, 0x35f, 0x256, 0x55a,
    0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5,
    0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65,
    0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460, 0xca0, 0xda9, 0xea3, 0xfaa,
    0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0, 0xd30,
    0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33,
    0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f,
    0x596, 0x29a, 0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
    0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0,
];

const TRI_TABLE: [[i8; 16]; 256] = [
    [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    ],
    [0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1],
    [3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1],
    [3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1],
    [3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1],
    [9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1],
    [9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
    [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1],
    [8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1],
    [9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
    [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1],
    [3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1],
    [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1],
    [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1],
    [4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1],
    [9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
    [5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1],
    [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1],
    [9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
    [0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
    [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1],
    [10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1],
    [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1],
    [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1],
    [5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1],
    [9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1],
    [0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1],
    [1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1],
    [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1],
    [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1],
    [2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1],
    [7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1],
    [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1],
    [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1],
    [11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1],
    [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1],
    [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1],
    [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1],
    [11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
    [1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1],
    [9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1],
    [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1],
    [2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
    [0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
    [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1],
    [6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1],
    [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1],
    [6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1],
    [5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1],
    [1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
    [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1],
    [6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1],
    [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1],
    [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1],
    [3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
    [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1],
    [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1],
    [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1],
    [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1],
    [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1],
    [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1],
    [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1],
    [10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1],
    [10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1],
    [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1],
    [1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1],
    [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1],
    [0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1],
    [10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1],
    [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1],
    [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1],
    [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1],
    [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1],
    [3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1],
    [6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1],
    [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1],
    [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1],
    [10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1],
    [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1],
    [7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1],
    [7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1],
    [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1],
    [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1],
    [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1],
    [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1],
    [0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1],
    [7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
    [10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
    [2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
    [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1],
    [7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1],
    [2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1],
    [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1],
    [10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1],
    [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1],
    [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1],
    [7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1],
    [6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1],
    [8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1],
    [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1],
    [6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1],
    [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1],
    [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1],
    [8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1],
    [0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1],
    [1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1],
    [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1],
    [10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1],
    [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1],
    [10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
    [5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
    [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1],
    [9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
    [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1],
    [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1],
    [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1],
    [7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1],
    [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1],
    [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1],
    [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1],
    [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1],
    [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1],
    [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1],
    [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1],
    [6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1],
    [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1],
    [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1],
    [6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1],
    [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1],
    [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1],
    [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1],
    [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1],
    [9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1],
    [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1],
    [1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1],
    [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1],
    [0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1],
    [5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1],
    [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1],
    [11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1],
    [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1],
    [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1],
    [2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1],
    [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1],
    [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1],
    [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1],
    [1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1],
    [9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1],
    [9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1],
    [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1],
    [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1],
    [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1],
    [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1],
    [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1],
    [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1],
    [9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1],
    [5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1],
    [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1],
    [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1],
    [8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1],
    [0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1],
    [9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1],
    [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1],
    [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1],
    [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1],
    [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1],
    [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1],
    [11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1],
    [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1],
    [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1],
    [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1],
    [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1],
    [1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1],
    [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1],
    [4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1],
    [0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1],
    [3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1],
    [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1],
    [0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1],
    [9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1],
    [1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    ],
];
===== lib/src/simulation.rs =====
use std::{collections::HashMap, sync::Mutex, any::Any};
use lazy_static::lazy_static;
use crate::dft_simulator::DFTSolver;

////////////////////////////////////////////////////////////////////////
/// Basis functions
////////////////////////////////////////////////////////////////////////

pub trait BasisFunction: Send + Sync {
    fn center(&self) -> [f32; 3];
    fn value(&self, point: &[f32; 3]) -> f32;
    fn clone_box(&self) -> Box<dyn BasisFunction>;
    fn as_any(&self) -> &dyn Any;
}

impl Clone for Box<dyn BasisFunction> {
    fn clone(&self) -> Box<dyn BasisFunction> {
        self.clone_box()
    }
}

#[derive(Debug, Clone)]
pub struct GaussianBasis {
    pub center: [f32; 3],
    pub alpha: f32,
}

impl BasisFunction for GaussianBasis {
    fn center(&self) -> [f32; 3] {
        self.center
    }
    fn value(&self, point: &[f32; 3]) -> f32 {
        let dx = point[0] - self.center[0];
        let dy = point[1] - self.center[1];
        let dz = point[2] - self.center[2];
        (-self.alpha * (dx * dx + dy * dy + dz * dz)).exp()
    }
    fn clone_box(&self) -> Box<dyn BasisFunction> {
        Box::new(self.clone())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}

/// A Cartesian Gaussian of arbitrary angular momentum (ℓₓ,ℓᵧ,ℓ𝓏).
#[derive(Debug, Clone)]
pub struct AngularGaussian {
    pub center: [f32; 3],
    pub alpha: f32,
    pub l: (usize, usize, usize),
}

impl BasisFunction for AngularGaussian {
    fn center(&self) -> [f32; 3] {
        self.center
    }

    fn value(&self, point: &[f32; 3]) -> f32 {
        let (lx, ly, lz) = self.l;
        let dx = point[0] - self.center[0];
        let dy = point[1] - self.center[1];
        let dz = point[2] - self.center[2];
        let r2 = dx * dx + dy * dy + dz * dz;

        let alpha = self.alpha;
        let lsum = (lx + ly + lz) as f32;

        // avoid underflow by treating lx==0 specially
        let df_x_arg = if lx == 0 { 0 } else { 2 * lx - 1 };
        let df_y_arg = if ly == 0 { 0 } else { 2 * ly - 1 };
        let df_z_arg = if lz == 0 { 0 } else { 2 * lz - 1 };

        let norm_prefactor = (2.0 * alpha / std::f32::consts::PI).powf(0.75);
        let poly_prefactor = (4.0 * alpha).powf(lsum / 2.0);

        let norm_denom = (
            double_factorial(df_x_arg) *
            double_factorial(df_y_arg) *
            double_factorial(df_z_arg)
        ).sqrt();

        let norm = norm_prefactor * poly_prefactor / norm_denom;

        norm
            * dx.powi(lx as i32)
            * dy.powi(ly as i32)
            * dz.powi(lz as i32)
            * (-alpha * r2).exp()
    }
    fn clone_box(&self) -> Box<dyn BasisFunction> {
        Box::new(self.clone())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }

}

fn double_factorial(n: usize) -> f32 {
    if n == 0 || n == 1 {
        1.0
    } else {
        (n as f32) * double_factorial(n - 2)
    }
}

////////////////////////////////////////////////////////////////////////

lazy_static! {
    pub static ref SIMULATION_STATE: Mutex<SimulationState> = Mutex::new(SimulationState::default());

    pub static ref SIMULATION_CONFIGS: Mutex<HashMap<String, SimulationConfig>> = {
        let mut m = HashMap::new();

        // Hydrogen (Gaussian)
        m.insert(
            "hydrogen".into(),
            SimulationConfig {
                nuclei: vec![Nucleus { species: "H".into(), atomic_number: 1, coordinates: [0.0, 0.0, 0.0] }],
                num_electrons: 1,
                basis: vec![Box::new(GaussianBasis { center: [0.0, 0.0, 0.0], alpha: 1.0})],
                points_per_axis: 32,
                tolerance: 1e-4
            },
        );

        // Helium
        m.insert(
            "helium".into(),
            SimulationConfig {
                nuclei: vec![Nucleus { species: "He".into(), atomic_number: 2, coordinates: [0.0, 0.0, 0.0] }],
                num_electrons: 2,
                basis: vec![Box::new(GaussianBasis { center: [0.0, 0.0, 0.0], alpha: 1.0})],
                points_per_axis: 32,
                tolerance: 1e-4
            },
        );

        // H2 molecule
        m.insert(
            "h2_molecule".into(),
            SimulationConfig {
                nuclei: vec![
                    Nucleus { species: "H".into(), atomic_number: 1, coordinates: [-1.0, 0.0, 0.0] },
                    Nucleus { species: "H".into(), atomic_number: 1, coordinates: [1.0, 0.0, 0.0] },
                ],
                num_electrons: 2,
                basis: vec![
                    Box::new(GaussianBasis { center: [-1.0, 0.0, 0.0], alpha: 4.0}),
                    Box::new(GaussianBasis { center: [1.0, 0.0, 0.0], alpha: 4.0,}),
                ],
                points_per_axis: 32,
                tolerance: 1e-1
            },
        );

        // H2 low-resolution
        m.insert(
            "h2_molecule_low_resolution".into(),
            SimulationConfig {
                nuclei: vec![
                    Nucleus { species: "H".into(), atomic_number: 1, coordinates: [-1.0, 0.0, 0.0] },
                    Nucleus { species: "H".into(), atomic_number: 1, coordinates: [1.0, 0.0, 0.0] },
                ],
                num_electrons: 2,
                basis: vec![
                    Box::new(GaussianBasis { center: [-0.37, 0.0, 0.0], alpha: 1.0}),
                    Box::new(GaussianBasis { center: [0.37, 0.0, 0.0], alpha: 1.0}),
                ],
                points_per_axis: 10,
                tolerance: 1e-1
            },
        );

        m.insert(
            "oxygen".into(),
            SimulationConfig {
                points_per_axis: 48,
                nuclei: vec![Nucleus {
                    species: "O".into(),
                    atomic_number: 8,
                    coordinates: [0.0, 0.0, 0.0],
                }],
                num_electrons: 8,
                basis: vec![
                    // Core 1s STO-3G-like
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 130.07, l: (0, 0, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 23.81, l: (0, 0, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 6.44, l: (0, 0, 0) }),

                    // 2s valence
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 0.1687, l: (0, 0, 0) }),

                    // 2p valence (px, py, pz)
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 1.1, l: (1, 0, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 1.1, l: (0, 1, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 1.1, l: (0, 0, 1) }),

                    // Optional diffuse d-functions
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 0.25, l: (2, 0, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 0.25, l: (0, 2, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 0.25, l: (0, 0, 2) }),
                ],
                tolerance: 1e-1
            },
        );
        m.insert(
            "oxygen_low_res".into(),
            SimulationConfig {
                points_per_axis: 20,
                nuclei: vec![Nucleus {
                    species: "O".into(),
                    atomic_number: 8,
                    coordinates: [0.0, 0.0, 0.0],
                }],
                num_electrons: 8,
                basis: vec![
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 130.070932 / 12.0, l: (0, 0, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 23.808861 / 12.0, l: (0, 0, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 6.4436083 / 12.0, l: (0, 0, 0) }),

                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 1.1 / 12.0, l: (1, 0, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 1.1 / 12.0, l: (0, 1, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 1.1 / 12.0, l: (0, 0, 1) }),

                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 0.1687144 / 12.0, l: (0, 0, 0) }),

                    // optional d‐functions
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 0.25 / 12.0, l: (2, 0, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 0.25 / 12.0, l: (0, 2, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 0.25 / 12.0, l: (0, 0, 2) }),
                ],
                tolerance: 1e-1
            },
        );

        m.insert(
            "oxygen_minimal".into(),
            SimulationConfig {
                nuclei: vec![Nucleus {
                    species: "O".into(),
                    atomic_number: 8,
                    coordinates: [0.0, 0.0, 0.0],
                }],
                num_electrons: 8,
                points_per_axis: 40,
                basis: vec![
                    // 1s core shell (3 Gaussian primitives)
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 130.70932, l: (0, 0, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 23.808861, l: (0, 0, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 6.4436083, l: (0, 0, 0) }),

                    // 2s valence shell
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 1.502, l: (0, 0, 0) }),

                    // 2p orbitals
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 1.502, l: (1, 0, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 1.502, l: (0, 1, 0) }),
                    Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 1.502, l: (0, 0, 1) }),
                ],
                tolerance: 1e-1
            },
        );

        Mutex::new(m)
    };
}

#[derive(Debug, Clone)]
pub enum SimulationStatus {
    Running,
    Completed,
    Failed,
}

#[derive(Debug, Clone)]
pub struct Nucleus {
    pub species: String,
    pub atomic_number: u32,
    pub coordinates: [f64; 3],
}

#[derive(Debug, Clone)]
pub struct SimulationState {
    pub total_time: f64,
    pub status: SimulationStatus,
    pub dft_simulator: DFTSolver,
    pub file_context: Option<String>,
}

impl SimulationState {
    pub fn new(total_time: f64, dft_simulator: DFTSolver, status: SimulationStatus) -> Self {
        let state = SimulationState {
            total_time,
            status,
            dft_simulator,
            file_context: None,
        };
        *SIMULATION_STATE.lock().unwrap() = state.clone();
        state
    }
    pub fn print_summary(&self) -> String {
        format!(
            "Simulation State:\n  Total Time: {:.3} a.u.\n  Status: {:?}\n",
            self.total_time, self.status
        )
    }
}

impl Default for SimulationState {
    fn default() -> Self {
        SimulationState {
            total_time: 1.0,
            status: SimulationStatus::Completed,
            dft_simulator: DFTSolver::new(),
            file_context: None,
        }
    }
}

#[derive(Clone)]
pub struct SimulationConfig {
    pub points_per_axis: usize,
    pub nuclei: Vec<Nucleus>,
    pub num_electrons: usize,
    pub basis: Vec<Box<dyn BasisFunction>>,
    pub tolerance: f32,
}

impl Default for SimulationConfig {
    fn default() -> Self {
        SimulationConfig {
            points_per_axis: 32,
            nuclei: vec![Nucleus {
                species: "H".into(),
                atomic_number: 1,
                coordinates: [0.0, 0.0, 0.0],
            }],
            num_electrons: 1,
            basis: vec![Box::new(AngularGaussian { center: [0.0, 0.0, 0.0], alpha: 1.0, l: (0,0,0)})],
            tolerance: 1e-5
        }
    }
}
===== log.txt =====
commit 5a21390ac60cbe3516530891d376da71f898e6c8
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Mon Jul 7 13:59:55 2025 +0100

    Note for the log
    
    Due to using a misconfiguring of my git global config despite having a concordant GPG access token, the commits diverge in authorship. Hence, breakdowns by contributor with yield interesting results. These can be safely ignore due to me acting as the sole developer (thus far? :D)

commit 6443ff0a6f19253036db32fbccebabe6e7604c99
Author: BobDaGithubAccount <bobdaducaddress@duck.com>
Date:   Wed Jul 2 18:49:35 2025 +0100

    Pushing changes (working on PME style poisson solver)

commit 3120af7336c60c50219f7007bcae28ed7bef31c3
Author: BobDaGithubAccount <bobdaducaddress@duck.com>
Date:   Wed Jul 2 16:30:19 2025 +0100

    Pushing changes

commit f5e82eb89946ac0db4d79f8816e4ac9ae6b04812
Author: BobDaGithubAccount <bobdaducaddress@duck.com>
Date:   Tue Jun 3 21:36:32 2025 +0100

    Partial progress towards working p orbitals (new normalisation scheme for angular momentum and other changes - ignore latex -> unicode as this is unique to my current IDE which I might not continue to use (also there isn't an ability to comment in a description so deal with the long commit name :D)

commit cc1111b112b7dde522ce0de729ee4501e06f0b74
Author: BobDaGithubAccount <bobdaducaddress@duck.com>
Date:   Thu May 29 15:41:40 2025 +0100

    Removed all formatting warnings and worked towards resolving convergence issues (working theory is that it's a periodic boundary conditions inducing resonance issue)

commit a9b0a6fb93f237210689b3757f0537fd564d7d68
Author: BobDaGithubAccount <bobdaducaddress@duck.com>
Date:   Wed May 28 11:30:38 2025 +0100

    Progress towards p orbital capable basis set

commit 6f9b594a495aeb097ca6edcfdecd6c77e043894e
Author: BobDaGithubAccount <bobdaducaddress@duck.com>
Date:   Tue May 27 19:48:18 2025 +0100

    Structural basis set handling changes (now generalisable)

commit 50fc91c7ff2f83946b06b9df31b535884a55baab
Author: BobDaGithubAccount <bobdaducaddress@duck.com>
Date:   Sun May 25 16:59:58 2025 +0100

    Progress (need to work on basis sets for accurate simulations)

commit 87f09853cd73c043066a35b098e91f81133bb739
Author: BobDaGithubAccount <bobdaducaddress@duck.com>
Date:   Sat May 24 17:19:41 2025 +0100

    Partially completed "fixed" solver, with overhauled solver (just refactored). Configuration streamlined (future JSON and web storage planned for assets)

commit 68d71c08ce893ba017365f84db2e46cb04797d4e
Author: BobDaGithubAccount <bobdaducaddress@duck.com>
Date:   Sat May 24 16:59:38 2025 +0100

    Made changes towards allowing for arbitary configuration

commit 442d2a9b9a72cdd7285dd56260c082585219d682
Author: BobDaGithubAccount <bobdaducaddress@duck.com>
Date:   Sat May 24 15:54:19 2025 +0100

    Refactorings

commit e70fdf2cac730c0a40f8a34a4d6c543517aca4e0
Author: BobDaGithubAccount <bobdaducaddress@duck.com>
Date:   Sat May 24 15:51:44 2025 +0100

    Transformed solver to use generalised eigenproblem, not symmetric eigen problem

commit 67e13b8c4192bad1e618a1d5142488daf790ab57
Author: BobDaGithubAccount <bobdaducaddress@duck.com>
Date:   Sat May 24 15:38:54 2025 +0100

    Removal of grid integrator code for brevity

commit e80657e1da29200adef66d5bde7f57d9d8e2d910
Author: BobDaGithubAccount <bobdaducaddress@duck.com>
Date:   Sat May 24 14:07:11 2025 +0100

    Added FFT based solving for better scaling

commit 63ef98bc3af1597afaa8c4c68e05fe3516eaa275
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Thu Feb 20 14:32:18 2025 +0000

    Changes

commit 80e2b9f05d510171ab2c3a540bb611f3e3ebaee5
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Wed Feb 19 22:15:35 2025 +0000

    Github statistics hotfix

commit d55ee17a2dae9a08de9a62c0369a944e944c4e95
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Wed Feb 19 22:09:32 2025 +0000

    Performance changes

commit 5fbe3b8bb866ba8140122c174c2ead589b35779c
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Wed Feb 19 21:51:06 2025 +0000

    Removed old code

commit 84e546e22004eeb564b8074250c5d54490e53092
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Wed Feb 19 21:50:17 2025 +0000

    Visibility changes

commit 29b3a9b50ca3b5e41bc0bcf74601a7db5a447933
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Wed Feb 19 21:45:22 2025 +0000

    Got marching cubes working!

commit 87878d012fbb938b6506c61cd845c1cb94be6641
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Mon Feb 17 21:33:25 2025 +0000

    Various changes

commit a0ad8fde557b8a581bcd1a00d1b744fb8e06d92b
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sat Feb 15 22:25:28 2025 +0000

    Formatting changes

commit 41bd0d433654ff254a554ba90fd7b0604c5706c6
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sat Feb 15 22:08:54 2025 +0000

    Note: push force erased two commits of approx 400 net additions previously

commit 8e0a210433787558c266a8e44cf7ec2330f4141b
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sat Feb 15 22:05:35 2025 +0000

    Got rust DFT simulator working (all i need to do now is get the rendering pipeline working)

commit deaa3c74961b9167fb5410c832bb23bf86fb59a9
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Sat Jan 18 17:52:55 2025 +0000

    Solid changes to rendering with marching cubes
    
    Still not working!

commit 91577927e6cb8cd171832b527858b5d95b3d4f16
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Fri Jan 17 19:05:06 2025 +0000

    Rust dft implementation
    
    I haven't hooked it in with my existing datastructures yet nor do I know if it works  yet. I will progress with getting rendering working with marching cubes first

commit 3b1d7dcffb0fed46d75e68420afd276f8c724394
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Mon Jan 13 15:53:01 2025 +0000

    Create log.log

commit 461b978ebb43d9fd9e355017a981ea3dd9fad761
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Mon Jan 13 15:52:36 2025 +0000

    Update .gitignore

commit a4e61fc7af4d49ea18acb5e0bac67e082920f141
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Sat Jan 4 20:08:07 2025 +0000

    bump

commit b364fd620749143406754fa2a33c3ece8338af71
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Sat Jan 4 20:07:30 2025 +0000

    Added gpu acceleration to the python simulation

commit f37c57ac7df6cbb53e11c3667ceb52bf313ca9ed
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Wed Jan 1 13:42:26 2025 +0000

    Pushed working changes
    
    For python implementation :D

commit 30152839301a41b186a65584455c05c1e5e1612e
Merge: 0b3ce9c 2eefacb
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Tue Dec 31 19:25:54 2024 +0000

    Merge branch 'main' of https://github.com/BobDaGithubAccount/Atomica

commit 0b3ce9cfd7119015290ed156d0d265729f9035a8
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Tue Dec 31 19:25:52 2024 +0000

    Pushing working changes for python implementation
    
    It DOES NOT work yet - incorrect number of eigenstates for some reason. Will fix

commit 2eefacb32d265644248f62f594d80f200e2ceed7
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sat Dec 21 17:55:08 2024 +0000

    Pushing working changes

commit 19563bf8026bb038a53b9f5d25cc8faf80d80663
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sun Dec 15 21:14:28 2024 +0000

    Started constructing state machine for simulation

commit 03f2b8c5c9cf75868b4158fa61b55559455649b4
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sat Dec 14 19:32:30 2024 +0000

    Edit README.md

commit e5b4e9b49ee20d57fb01822e9b3150e5fff7b314
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sat Dec 14 19:30:01 2024 +0000

    Refactor renderer module and move camera instance management

commit a98004f676401d0d697ff04f0efc45ea7664cc78
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sat Dec 14 19:24:59 2024 +0000

    Fixed error

commit f84b483398c21c9c169f992f3dfa4518f558dff5
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sat Dec 14 13:18:22 2024 +0000

    Added help command

commit 6cc4e27ccedd5e0563efec020963058648907aeb
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sat Dec 14 13:15:01 2024 +0000

    Changed register_command macro

commit f79c9fe91e6db4784423046b75639bc25b74ba43
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sat Dec 14 13:13:12 2024 +0000

    Added reset camera command

commit c0ed1deba2e5e3ef91a79ca9cc88404f63a3f3f5
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sat Dec 14 13:07:24 2024 +0000

    Logging and command changes

commit 7b9bb8ea32abc6bd932bb686bb5c088b8c6e9de8
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sat Dec 14 11:33:33 2024 +0000

    Added FOV change functionality

commit 3f318e099b925b593e6e2487380398cd72d100e6
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Fri Dec 13 16:03:46 2024 +0000

    Created command registry framework

commit 1a82485dea6d552b56222c94ee9c53063d12064d
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Wed Dec 11 13:45:41 2024 +0000

    Sorted out aspect ratios with the GUI

commit cc21d67b4e71d330f94b29218c277adf24981386
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Tue Dec 10 21:30:46 2024 +0000

    Made GUI changes

commit e57452dcc4a2e6e69b3eba16e3992f87b7b92488
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Sat Nov 16 10:03:11 2024 +0000

    Localisation and event handling changes

commit 93d711588d4a47414f2c70305d2e3997e2dbf44a
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Fri Nov 15 18:14:00 2024 +0000

    Resizing capability
    
    By copying and scaling the output from an invisible canvas, I can ensure that I can always scale the context without dealing with pipeline internals (e.g. dynamic frame buffers)

commit ffbb904d49e8381c4490c10da37ce82fae6414fc
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Mon Nov 11 15:56:00 2024 +0000

    Update index.html

commit ac79c9455abf1f89d8b348c135bd130138d33be8
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Tue Oct 29 11:55:41 2024 +0000

    Add rustup installation check and update in setup script

commit 03aa316838112933697060d6328113ac807267e5
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Tue Oct 29 11:53:29 2024 +0000

    Added setup script

commit f6cce37d6fabf8216fb95b4761f56e278ca6186f
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Tue Oct 29 11:51:50 2024 +0000

    Cleaned up .idea folder

commit 1c919cff9d22bd84f1c5f17e7aa0069d49bac823
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sun Oct 27 15:48:24 2024 +0000

    Refactor build scripts and update file paths

commit 67afa84969e813b2320a5c89860fd38bf155bd46
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sun Oct 27 15:42:43 2024 +0000

    Localisation changes

commit b4d07bb856f1a517db7437d06194b9dbc4e6e9cb
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Sun Oct 27 11:14:54 2024 +0000

    Overhauled rendering internals and introduced a new workflow

commit e5cdd01b1f0fc60f4d43c9d7a21a9f06165a8439
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Tue Oct 22 16:12:10 2024 +0100

    Updated .gitignore

commit 3bf7bfc23fde61c8159a9a6f1e998ab9ebd7f4a4
Merge: 3da29db ed6bcc6
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Tue Oct 22 16:11:16 2024 +0100

    Merge remote-tracking branch 'origin/main'

commit 3da29db1a4a7c4f832d9ab3b2bf192cef5586b00
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Tue Oct 22 16:10:55 2024 +0100

    Updated .gitignore

commit ed6bcc6547a15826bfb754999a68df06137ee371
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Tue Oct 22 16:08:47 2024 +0100

    Update README.md

commit 12069d935fc2642c161b5f1772309e18d25df9e2
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Tue Oct 22 16:03:22 2024 +0100

    Changed workflows - (just commiting to see if the permissions are now correctly configured)

commit b57e4fb6bd7cab5217994c5576aeb4e2f1703017
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Tue Oct 22 15:51:09 2024 +0100

    Changed workflows

commit 2f128a3d8bb5ad341ff6f768f8ac09f0628164e0
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Tue Oct 22 15:45:59 2024 +0100

    Changed workflows

commit c678d227fd0fac282988a146b579b026011a2630
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Tue Oct 22 15:41:03 2024 +0100

    Added diagnositc telemetry

commit f94c535de6ade1d6acd3c5fc3429cf546b7281d7
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Tue Oct 22 15:39:17 2024 +0100

    Edited deploy.yml

commit 9259d0f2be8f4082e28795931143f40d8beb526c
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Tue Oct 22 15:37:31 2024 +0100

    Changed gitignore and edited GitHub Pages Workflows

commit 53d46c47dfc3386b0404cff1cddf309dfb662e91
Author: BobDaGithubAccount <bobdaduckaddress@duck.com>
Date:   Tue Oct 15 18:05:18 2024 +0100

    Established MVP
    
    - Configured toolchains and implemented a three-d example to get the first steps working
    - TODO: Create a unit testing framework and get GitHub Actions working correctly

commit 145c991d412963762e5e637e381c19f44646e9c0
Author: BobDaGithubAccount <62474433+BobDaGithubAccount@users.noreply.github.com>
Date:   Sun Oct 13 17:12:31 2024 +0100

    Initial commit

===== package-lock.json =====
{
  "name": "atomica",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "atomica",
      "version": "1.0.0",
      "license": "ISC",
      "dependencies": {
        "express": "^4.21.2"
      }
    },
    "node_modules/accepts": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
      "integrity": "sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==",
      "dependencies": {
        "mime-types": "~2.1.34",
        "negotiator": "0.6.3"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/array-flatten": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
      "integrity": "sha512-PCVAQswWemu6UdxsDFFX/+gVeYqKAod3D3UVm91jHwynguOwAvYPhx8nNlM++NqRcK6CxxpUafjmhIdKiHibqg=="
    },
    "node_modules/body-parser": {
      "version": "1.20.3",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.3.tgz",
      "integrity": "sha512-7rAxByjUMqQ3/bHJy7D6OGXvx/MMc4IqBn/X0fcM1QUcAItpZrBEYhWGem+tzXH90c+G01ypMcYJBO9Y30203g==",
      "dependencies": {
        "bytes": "3.1.2",
        "content-type": "~1.0.5",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "on-finished": "2.4.1",
        "qs": "6.13.0",
        "raw-body": "2.5.2",
        "type-is": "~1.6.18",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/call-bind": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.7.tgz",
      "integrity": "sha512-GHTSNSYICQ7scH7sZ+M2rFopRoLh8t2bLSW6BbgrtLsahOIB5iyAVJf9GjWK3cYTDaMj4XdBpM1cA6pIS0Kv2w==",
      "dependencies": {
        "es-define-property": "^1.0.0",
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2",
        "get-intrinsic": "^1.2.4",
        "set-function-length": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/content-disposition": {
      "version": "0.5.4",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.4.tgz",
      "integrity": "sha512-FveZTNuGw04cxlAiWbzi6zTAL/lhehaWbTtgluJh4/E95DqMwTmha3KZN1aAWA8cFIhHzMZUvLevkw5Rqk+tSQ==",
      "dependencies": {
        "safe-buffer": "5.2.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.7.1",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.1.tgz",
      "integrity": "sha512-6DnInpx7SJ2AK3+CTUE/ZM0vWTUboZCegxhC2xiIydHR9jNuTAASBrfEpHhiGOZw/nX51bHt6YQl8jsGo4y/0w==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-signature": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.6.tgz",
      "integrity": "sha512-QADzlaHc8icV8I7vbaJXJwod9HWYp8uCqf1xa4OfNu1T7JVxQIrUgOWtHdNDtPiywmFbiS12VjotIXLrKM3orQ=="
    },
    "node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/define-data-property": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/define-data-property/-/define-data-property-1.1.4.tgz",
      "integrity": "sha512-rBMvIzlpA8v6E+SJZoo++HAYqsLrkg7MSfIinMPFhmkorw7X+dOXVJQs+QT69zGkzMyfDnIMN2Wid1+NbL3T+A==",
      "dependencies": {
        "es-define-property": "^1.0.0",
        "es-errors": "^1.3.0",
        "gopd": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/destroy": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.2.0.tgz",
      "integrity": "sha512-2sJGJTaXIIaR1w4iJSNoN0hnMY7Gpc/n8D4qSCJw8QqFWXf7cuAgnEHxBpweaVcPevC2l3KpjYCx3NypQQgaJg==",
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow=="
    },
    "node_modules/encodeurl": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.0.tgz",
      "integrity": "sha512-jxayLKShrEqqzJ0eumQbVhTYQM27CfT1T35+gCgDFoL82JLsXqTJ76zv6A0YLOgEnLUMvLzsDsGIrl8NFpT2gQ==",
      "dependencies": {
        "get-intrinsic": "^1.2.4"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow=="
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/express": {
      "version": "4.21.2",
      "resolved": "https://registry.npmjs.org/express/-/express-4.21.2.tgz",
      "integrity": "sha512-28HqgMZAmih1Czt9ny7qr6ek2qddF4FclbMzwhCREB6OFfH+rXAnuNCwo1/wFvrtbgsQDb4kSbX9de9lFbrXnA==",
      "license": "MIT",
      "dependencies": {
        "accepts": "~1.3.8",
        "array-flatten": "1.1.1",
        "body-parser": "1.20.3",
        "content-disposition": "0.5.4",
        "content-type": "~1.0.4",
        "cookie": "0.7.1",
        "cookie-signature": "1.0.6",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "finalhandler": "1.3.1",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "merge-descriptors": "1.0.3",
        "methods": "~1.1.2",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "path-to-regexp": "0.1.12",
        "proxy-addr": "~2.0.7",
        "qs": "6.13.0",
        "range-parser": "~1.2.1",
        "safe-buffer": "5.2.1",
        "send": "0.19.0",
        "serve-static": "1.16.2",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "type-is": "~1.6.18",
        "utils-merge": "1.0.1",
        "vary": "~1.1.2"
      },
      "engines": {
        "node": ">= 0.10.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/finalhandler": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.3.1.tgz",
      "integrity": "sha512-6BN9trH7bp3qvnrRyzsBz+g3lZxTNZTbVO2EV1CS0WIcDbawYVdYvGflME/9QP0h0pYlCDBCTjYa9nZzMDpyxQ==",
      "dependencies": {
        "debug": "2.6.9",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "statuses": "2.0.1",
        "unpipe": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "0.5.2",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
      "integrity": "sha512-zJ2mQYM18rEFOudeV4GShTGIQ7RbzA7ozbU9I/XBpm7kqgMywgmylMwXHxZJmkVoYkna9d2pVXVXPdYTP9ej8Q==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.2.4.tgz",
      "integrity": "sha512-5uYhsJH8VJBTv7oslg4BznJYhDoRI6waYCxMmCdnTrcCrHA/fCFKoTFz2JKKE0HdDFUF7/oQuhzumXJK7paBRQ==",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2",
        "has-proto": "^1.0.1",
        "has-symbols": "^1.0.3",
        "hasown": "^2.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gopd": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.0.1.tgz",
      "integrity": "sha512-d65bNlIadxvpb/A2abVdlqKqV563juRnZ1Wtk6s1sIR8uNsXR70xqIzVqxVf1eTqDunwT2MkczEeaezCKTZhwA==",
      "dependencies": {
        "get-intrinsic": "^1.1.3"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-property-descriptors": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-property-descriptors/-/has-property-descriptors-1.0.2.tgz",
      "integrity": "sha512-55JNKuIW+vq4Ke1BjOTjM2YctQIvCT7GFzHwmfZPGo5wnrgkid0YQtnAleFSqumZm4az3n2BS+erby5ipJdgrg==",
      "dependencies": {
        "es-define-property": "^1.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-proto": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/has-proto/-/has-proto-1.0.3.tgz",
      "integrity": "sha512-SJ1amZAJUiZS+PhsVLf5tGydlaVB8EdFpaSO4gmiUKUOxk8qzn5AIy4ZeJUmh22znIdk/uMAUT2pl3FxzVUH+Q==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.3.tgz",
      "integrity": "sha512-l3LCuF6MgDNwTDKkdYGEihYjt5pRPbEg46rtlmnSPlUbgmB8LOIrKJbYYFBSbnPaJexMKtiPO8hmeRjRz2Td+A==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/http-errors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
      "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
      "dependencies": {
        "depd": "2.0.0",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/media-typer": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
      "integrity": "sha512-dq+qelQ9akHpcOl/gUVRTxVIOkAJ1wR3QAvb4RsVjS8oVoFjDGTc679wJYmUmknUF5HwMLOgb5O+a3KxfWapPQ==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/merge-descriptors": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.3.tgz",
      "integrity": "sha512-gaNvAS7TZ897/rVaZ0nMtAyxNyi/pdbjbAwUpFQpN70GqnVfOiXpeUUMKRBmzXaSQ8DdTX4/0ms62r2K+hE6mQ==",
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/methods": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/methods/-/methods-1.1.2.tgz",
      "integrity": "sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/mime/-/mime-1.6.0.tgz",
      "integrity": "sha512-x0Vn8spI+wuJ1O6S7gnbaQg8Pxh4NNHb7KSINmEWKiPE4RKOplvijn+NkmYmmRgP68mc70j2EbeTFRsrswaQeg==",
      "bin": {
        "mime": "cli.js"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A=="
    },
    "node_modules/negotiator": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.3.tgz",
      "integrity": "sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.2",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.2.tgz",
      "integrity": "sha512-IRZSRuzJiynemAXPYtPe5BoI/RESNYR7TYm50MC5Mqbd3Jmw5y790sErYw3V6SryFJD64b74qQQs9wn5Bg/k3g==",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "0.1.12",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
      "integrity": "sha512-RA1GjUVMnvYFxuqovrEqZoxxW5NUZqbwKtYz/Tt7nXerk0LbLblQmrsgdeOxV5SFHf0UDggjS/bSeOZwt1pmEQ=="
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/qs": {
      "version": "6.13.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.13.0.tgz",
      "integrity": "sha512-+38qI9SOr8tfZ4QmJNplMUxqjbe7LKvvZgWdExBOmd+egZTtjLB67Gu0HRX3u/XOq7UU2Nx6nsjvS16Z9uwfpg==",
      "dependencies": {
        "side-channel": "^1.0.6"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "2.5.2",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.5.2.tgz",
      "integrity": "sha512-8zGqypfENjCIqGhgXToC8aB2r7YrBX+AQAfIPs/Mlk+BtPTztOvTS01NRW/3Eh60J+a48lt8qsCzirQ6loCVfA==",
      "dependencies": {
        "bytes": "3.1.2",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
    },
    "node_modules/send": {
      "version": "0.19.0",
      "resolved": "https://registry.npmjs.org/send/-/send-0.19.0.tgz",
      "integrity": "sha512-dW41u5VfLXu8SJh5bwRmyYUbAoSB3c9uQh6L8h/KtsFREPWpbX1lrljJo186Jc4nmci/sGUZ9a0a0J2zgfq2hw==",
      "dependencies": {
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "mime": "1.6.0",
        "ms": "2.1.3",
        "on-finished": "2.4.1",
        "range-parser": "~1.2.1",
        "statuses": "2.0.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/send/node_modules/encodeurl": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
      "integrity": "sha512-TPJXq8JqFaVYm2CWmPvnP2Iyo4ZSM7/QKcSmuMLDObfpH5fi7RUGmd/rTDf+rut/saiDiQEeVTNgAmJEdAOx0w==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/send/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA=="
    },
    "node_modules/serve-static": {
      "version": "1.16.2",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.16.2.tgz",
      "integrity": "sha512-VqpjJZKadQB/PEbEwvFdO43Ax5dFBZ2UECszz8bQ7pi7wt//PWe1P6MN7eCnjsatYtBT6EuiClbjSWP2WrIoTw==",
      "dependencies": {
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "parseurl": "~1.3.3",
        "send": "0.19.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/set-function-length": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/set-function-length/-/set-function-length-1.2.2.tgz",
      "integrity": "sha512-pgRc4hJ4/sNjWCSS9AmnS40x3bNMDTknHgL5UaMBTMyJnU90EgWh1Rz+MC9eFu4BuN/UwZjKQuY/1v3rM7HMfg==",
      "dependencies": {
        "define-data-property": "^1.1.4",
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2",
        "get-intrinsic": "^1.2.4",
        "gopd": "^1.0.1",
        "has-property-descriptors": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
    },
    "node_modules/side-channel": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.0.6.tgz",
      "integrity": "sha512-fDW/EZ6Q9RiO8eFG8Hj+7u/oW+XrPTIChwCOM2+th2A6OblDtYYIpve9m+KvI9Z4C9qSEXlaGR6bTEYHReuglA==",
      "dependencies": {
        "call-bind": "^1.0.7",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.4",
        "object-inspect": "^1.13.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/statuses": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
      "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/type-is": {
      "version": "1.6.18",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
      "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
      "dependencies": {
        "media-typer": "0.3.0",
        "mime-types": "~2.1.24"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/utils-merge": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
      "integrity": "sha512-pMZTvIkT1d+TFGvDOqodOclx0QWkkgi6Tdoa8gC8ffGAAqz9pzPTZWAybbsHHoED/ztMtkv/VoYTYyShUn81hA==",
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "engines": {
        "node": ">= 0.8"
      }
    }
  }
}

===== package.json =====
{
  "name": "atomica",
  "version": "1.0.0",
  "description": "A web based molecular dynamics simulator implemented in rust",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "run": "bash .github/workflows/run.sh",
    "build": "bash .github/workflows/build.sh",
    "quickrun": "bash .github/workflows/quick-build.sh && node index.js",
    "setup": "bash .github/workflows/setup.sh"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/BobDaGithubAccount/Atomica.git"
  },
  "keywords": [],
  "author": "Stanley Howard",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/BobDaGithubAccount/Atomica/issues"
  },
  "homepage": "https://github.com/BobDaGithubAccount/Atomica#readme",
  "dependencies": {
    "express": "^4.21.2"
  }
}

===== src/index.html =====
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Atomica</title>
        <style>
            body, html {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                display: flex;
                flex-direction: column;
            }

            #top-bar {
                height: 5vh;
                background-color: #333;
                color: #fff;
                display: flex;
                align-items: center;
                padding: 0 10px;
            }

            #main-container {
                display: flex;
                width: 100%;
                height: 95vh;
            }

            #canvas-container {
                flex: 3;
                display: flex;
                justify-content: center;
                align-items: center;
                border: 1px solid #333;
            }

            #canvas {
                width: 100%;
                height: 100%;
            }

            #console-container {
                flex: 1;
                display: flex;
                flex-direction: column;
                background-color: #333;
                color: #fff;
                padding: 10px;
                border: 1px solid #333;
            }

            #log-area {
                flex: 1;
                overflow-y: auto;
                background-color: #222;
                padding: 10px;
                margin-bottom: 10px;
            }

            #input-area {
                display: flex;
            }

            #command-input {
                flex: 1;
                padding: 10px;
                border: none;
                border-radius: 4px 0 0 4px;
            }

            #send-button {
                padding: 10px;
                border: none;
                border-radius: 0 4px 4px 0;
                background-color: #555;
                color: #fff;
                cursor: pointer;
                transition: background-color 0.3s;
            }

            #send-button:hover {
                background-color: #777;
            }
        </style>
    </head>
    <body>
        <div id="top-bar">
            <!-- Future stuff here! (probably not D:) -->
        </div>
        <div id="main-container">
            <div id="canvas-container">
                <canvas id="canvas"></canvas>
            </div>
            <div id="console-container">
                <div id="log-area"></div>
                <div id="input-area">
                    <input id="command-input" type="text" placeholder="Enter commands here...">
                    <button id="send-button">Send</button>
                </div>
            </div>
        </div>

        <script type="module" src="index.js"></script>
    </body>
</html>
===== src/index.js =====
import init, * as wasm_bindgen from './atomica_lib.js';
import { handle_command, log } from './atomica_lib.js';

function jsInit() {
    console.log("Wasm module initialized");
    const canvas = document.getElementById('canvas');
    const sendButton = document.getElementById('send-button');
    const commandInput = document.getElementById('command-input');
    const logArea = document.getElementById('log-area');

    sendButton.addEventListener('click', () => {
        const command = commandInput.value.trim();
        if (command) {
            log(`User command: ${command}`);
            commandInput.value = '';
            handle_command_js(command);
        }
    });

    commandInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
            sendButton.click();
        }
    });
}

function handle_command_js(command) {
    handle_command(command);
}

init().then(() => {
    jsInit();
}).catch(err => {
    console.error("Fake error initializing wasm module:", err);
    try {
        console.log("Second round of initialization successful! (Control flow error warning bypassed)");
        jsInit();
    } catch (err) {
        log("Real error initializing wasm module: " + err);
    }
});
